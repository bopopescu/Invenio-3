# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2009, 2010, 2011, 2012, 2013 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""
BibFigure merge - plots merger

Process the latex extractor and pdf extractor by executing functions of matching
and merging. The final result is written to a MARCXML.
It was designed to support the new BIBDOCFILE format, but it is also available
for the current model.
"""

import os
import re
import sys
import codecs
import datetime
import base64
import cPickle

from invenio.textutils import translate_latex2unicode
from invenio.config import CFG_ETCDIR
from invenio.bibtask import write_message
from invenio.bibfigure import output_record, \
				parse_record, \
				output_string, \
				parse_json, \
				Figure
from invenio.bibfigure_utils import levenshtein, \
					backTrack, \
					iterative, \
					LCS, \
					strip_control_characters
									
def merging_latex_pdf(file_xml, file_json, id_fulltext, extracted):
	"""
	Function that merges two files
	
	@param file_xml: file that is generated by Plot extractor
	@param file_json: file that is generated by PDF extractor

	@return: code={0-latex and pdf figures extracted, 1-latex figures not present,
			 2-pdf figures not present or latex&pdf figures not present},
     		 message - any error messages
		 the vector of all figures
		 marc_path - the path of the created MARCXML file
	"""

	(code, message, list_of_figures_from_latex, list_of_figures_from_pdf) = getFigureVectors(file_xml, file_json)

	(tuples, updated_list_latex, updated_list_pdf) = doMatching(list_of_figures_from_latex, list_of_figures_from_pdf)

	figures = doMerging(tuples, updated_list_latex, updated_list_pdf, True)

	marc_path = create_MARCXML(figures, id_fulltext, code, extracted, True)
	# for old model
	# marc_path = create_MARCXML_old_format(figures, extracted, True)
	write_message("Merge file %s" %marc_path)
	return (code, message, figures, marc_path)

def create_MARCXML_old_format(figures, extracted, write_file=True):
	"""
	Function that creates a file MARCXML in old format - see code in plotextractor_output_utils.py
	
	@param figures: the list of all figures
	@param extracted: where the file will be generated
	@param write_file: it's True when the user wants to write the data into file
	
	@return: the path to the MARCXML file 
	"""
	both_doc = 0
	no_latex = 1
	no_pdf = 2
	list = []
	list.append('<?xml version="1.0" encoding="UTF-8"?>')
	list.append('<collection>')
	
	list.append('<record>')
	figure_number = 1
	for figure in figures:
		for i in range(len(figure.files)):
			list.append('    <datafield tag="FFT" ind1=" " ind2=" ">')
			list.append('      <subfield code="a">' + figure.files[i].path + '</subfield>')

			if "plotextractor_dummy.png" in figure.files[i].path:
				list.append('      <subfield code="t">PlotMisc</subfield>')
			else:
				list.append('      <subfield code="t">Plot</subfield>')

			if ".png.context" in figure.files[i].path:
				list.append('      <subfield code="f">.png;context</subfield>')
			#doar daca a nu contine .png;context
			else:
				list.append('      <subfield code="d">' + figure.caption + '</subfield>')

			list.append('      <subfield code="n">' + figure.identifier + '</subfield>')

			if ".png.context" in figure.files[i].path or "plotextractor_dummy.png" in figure.files[i].path:
				list.append('      <subfield code="o">hidden</subfield>')

			list.append('    </datafield>')

		figure_number = figure_number + 1
	
	list.append('</record>')
	list.append('</collection>')
	marc = '\n'.join(list)
	if write_file:
		marc_path = str(extracted) + "/extracted.xml"
		f = codecs.open(marc_path, encoding="utf-8", mode="a")
		f.write(marc)
		f.close()
	return marc_path

def create_MARCXML(figures, id_fulltext, code, extracted, write_file=True):
	"""
	Function that creates a file MARCXML from the vector of figures
	
	@param figures: the list of all figures
	@param id_fulltext: the id of the fulltext
	@param code: The code for Latex, PDF or both 
	@param extracted: where the file will be generated
	@param write_file: it's True when the user wants to write the data into file
	
	@return: the path to the MARCXML file 
	"""
	both_doc = 0
	no_latex = 1
	no_pdf = 2
	list = []
	list.append('<?xml version="1.0" encoding="UTF-8"?>')
	list.append('<collection>')

	figure_number = 1
	parent_id = -1
	for figure in figures:
		if figure.subfigure != None:		
			if 'is subfigure of' in figure.subfigure:
				print 'ok'
				print figure.identifier
		list.append('<record>')
		for i in range(len(figure.files)):
			text_references = ""
			if not figure.files[i].path.endswith("context"):
				list.append('    <datafield tag="FFT" ind1=" " ind2=" ">')
				list.append('      <subfield code="a">' + figure.files[i].path + '</subfield>')
				list.append('      <subfield code="r">restricted_pict</subfield>')
				list.append('      <subfield code="n">' + figure.identifier + '</subfield>')
				list.append('      <subfield code="d">' + figure.caption + '</subfield>')
				if i == 0:
					if(figure.subfigure != None):
						if 'is subfigure of' in figure.subfigure:
							list.append('      <subfield code="i">TMP:SUBFIGURE:' + str(id_fulltext) + ':' + str(figure.subfigure_id) + '</subfield>')
							list.append('      <subfield code="v">TMP:SUBFIGURE:' + str(id_fulltext) + ':v' + str(figure.subfigure_id) + '</subfield>')
					else:
						list.append('      <subfield code="i">TMP:' + str(id_fulltext) + ':' + str(figure_number) + '</subfield>')
						list.append('      <subfield code="v">TMP:' + str(id_fulltext) + ':v' + str(figure_number) + '</subfield>')
						if figure.is_parent != None:						
							if 'is parent' in figure.is_parent:
								parent_id = figure_number
				list.append('    </datafield>')

			else:
				text_references = figure.text_references
			if i < len(figure.files)-1:
				list.append('\n')
#			if i == len(figure.files) - 1:
#				list.append('  </record>')
			# if we have the fulltext pdf we add the BDR tag after the FFT tag
			if code != no_pdf and i == len(figure.files) - 1:
				list.append('    <datafield tag="BDR" ind1=" " ind2=" ">')
#				list.append('	<subfield code="i">TMP:OAI:' + str(figure_number) + '</subfield>')
#				list.append('	<subfield code="v">TMP:OAI:' + str(figure_number) + 'v' + '</subfield>')
# id, v1, id, v  
				if(figure.subfigure != None):
					if 'is subfigure of' in figure.subfigure:
						list.append('      <subfield code="i">TMP:SUBFIGURE:' + str(id_fulltext) + ':' + str(figure.subfigure_id) + '</subfield>')
						list.append('      <subfield code="v">TMP:SUBFIGURE:' + str(id_fulltext) + ':v' + str(figure.subfigure_id) + '</subfield>')
						list.append('      <subfield code="j">TMP:' + str(id_fulltext) + ':' + str(parent_id) + '</subfield>')
						list.append('      <subfield code="w">TMP:' + str(id_fulltext) + ':v' + str(parent_id) + '</subfield>')
						list.append('      <subfield code="t">is_subfigure_of</subfield>')	
						figure_number  = figure_number - 1	
				else:

					list.append('      <subfield code="i">TMP:' + str(id_fulltext) + ':' + str(figure_number) + '</subfield>')
					list.append('      <subfield code="v">TMP:' + str(id_fulltext) + ':v' + str(figure_number) + '</subfield>')
					list.append('      <subfield code="j">TMP:' + str(id_fulltext) + '</subfield>')
					list.append('      <subfield code="w">TMP:' + str(id_fulltext) + ':v' + '</subfield>')
					list.append('      <subfield code="t">is_extracted_from</subfield>')
				dict = {}
				dict["figures"]={}
				dict["figures"]["caption"]=figure.caption
				write_message("adding field figure.caption")
				v = ["location", "caption_location"]
				for i, item in enumerate(v):
					if(figure.get_location(i) != None):
						dict["figures"][item]={}
						dict["figures"][item]["page_num"] = figure.get_location(i).page_num
						write_message("adding figure.get_location.page_num")
						if(figure.get_location(i).page_resolution != None):
							dict["figures"][item]["page_resolution"]={}
							dict["figures"][item]["page_resolution"]["width"]=figure.get_location(i).page_resolution.width
							write_message("adding figure.get_location.page_resolution.page_num_width")
							dict["figures"][item]["page_resolution"]["height"]=figure.get_location(i).page_resolution.height
							write_message("adding figure.get_location.page_resolution.height")
						if(figure.get_location(i).boundary != None):
							dict["figures"][item]["boundary"]={}
							dict["figures"][item]["boundary"]["width"]=figure.get_location(i).boundary.width
							write_message("adding figure.get_location.boundary.width")
							dict["figures"][item]["boundary"]["height"]=figure.get_location(i).boundary.height
							write_message("adding figure.get_location.boundary.height")
							dict["figures"][item]["boundary"]["x"]=figure.get_location(i).boundary.x
							write_message("adding figure.get_location.boundary.x")
							dict["figures"][item]["boundary"]["y"]=figure.get_location(i).boundary.y
							write_message("adding figure.get_location.boundary.y")
						if i==0:
							dict["figures"][item]["page_scale"]=figure.get_location(i).page_scale
							write_message("adding figure.get_location.page_scale")
				dict["figures"]["text_references"] = text_references
				write_message("adding figure.text_references")
				
				d = cPickle.dumps(dict)
				info = base64.encodestring(d)
				list.append('      <subfield code="m">' + info + '</subfield>')
				list.append('    </datafield>')
		figure_number = figure_number + 1
		list.append('</record>')
	list.append('</collection>')
	marc = '\n'.join(list)
	if write_file:
		marc_path = str(extracted) + "/extracted.xml"
		f = codecs.open(marc_path, encoding="utf-8", mode="a")
		#f = open(marc_path, 'a')
		f.write(marc)
		f.close()
	return marc_path


def doMerging(tuples, list_latex, list_pdf, add_subfigure=False):
	"""
	Function that goes through tuples and merge. The rest of figures are taken from
	untouched figures from latex and pdf.

	@param tuples: the index of figures that are the same
	@param list_latex: the list of all figures from latex extractor
	@param list_pdf: the list of all figures from pdf extractor

	@return figures: the list of figures after merging process
	"""
	figures = []
	merge_tuples = [tuple for tuple in tuples]

	if add_subfigure:
		# dict = {p:[l,l,l], p:[l,l,l]}
		dict = pdf_is_in_multiple_tuples(tuples)

		for p in dict.keys():
			index_figure_pdf = p
			index_figure_latex = dict[p][0]

			figure_pdf = list_pdf[index_figure_pdf]
			figure_latex = list_latex[index_figure_latex]

			id = figure_pdf.identifier
			s_d = figure_pdf.source_document
			c = figure_pdf.caption
			c_f = figure_pdf.caption_file
			f = figure_pdf.files
			l = figure_pdf.location
			c_l = figure_pdf.caption_location
			a_i = figure_pdf.annotated_image

			for index, a_file in enumerate(figure_latex.files):
				if index != 0:
					f.append(a_file)
			s = figure_latex.status
			t_r = figure_latex.text_references
			is_p = "is parent"
			figures.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i, status=s, text_references=t_r, is_parent=is_p))

			count = 1
			for l in dict[p]:
				figure_latex = list_latex[l]
				id = figure_pdf.identifier
				c = figure_pdf.caption
				f = figure_latex.files	
				s = figure_latex.status
				t_r = figure_latex.text_references
				s_f = "is subfigure of"
				s_id = count
				figures.append(Figure(identifier=id, caption=c, files=f, status=s, text_references=t_r, subfigure=s_f, subfigure_id = s_id))
				count = count + 1
				merge_tuples.remove((l,p))

	for index, t in enumerate(merge_tuples):
		index_figure_latex = t[0]
		index_figure_pdf = t[1]
		
		figure_latex = list_latex[index_figure_latex]
		figure_pdf = list_pdf[index_figure_pdf]

		id = figure_pdf.identifier
		s_d = figure_pdf.source_document
		c = figure_pdf.caption
		c_f = figure_pdf.caption_file
		f = figure_pdf.files
		l = figure_pdf.location
		c_l = figure_pdf.caption_location
		a_i = figure_pdf.annotated_image

		for index, a_file in enumerate(figure_latex.files):
			if index != 0:
				f.append(a_file)
		s = figure_latex.status
		t_r = figure_latex.text_references
		figures.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i, status=s, text_references=t_r))
	
	for index, figure in enumerate(list_latex):
		if index_not_in_tuples(index, tuples, "latex"):
			id = figure.identifier
			c = figure.caption
			f = figure.files
			s = figure.status
			t_r = figure.text_references
			figures.append(Figure(identifier=id, caption=c, files=f, status=s, text_references=t_r))
		
	for index, figure in enumerate(list_pdf):
		if index_not_in_tuples(index, tuples, "pdf"):
			id = figure.identifier
			s_d = figure.source_document
			c = figure.caption
			c_f = figure.caption_file
			f = figure.files
			l = figure.location
			c_l = figure.caption_location
			a_i = figure.annotated_image
			figures.append(Figure(identifier=id, source_document=s_d, caption=c, caption_file=c_f, files=f, location=l, caption_location=c_l, annotated_image=a_i))

	return figures


def get_captions(list_latex, list_pdf):
	"""
	Function that takes all the caption from latex and pdf and creates a list for each case.
	Also it transforms all the latex simbols in unicode, removes any spaces or endline and
	removes Fig.<number>. Those transforms are used in the next step of matching captions.
	The original caption is obviously saved and put into MARCXML later.

	@param list_latex
	@param list_pdf

	@return caption_list_latex, caption_list_pdf, update_list_latex, update_list_pdf
	"""
	caption_list_latex = [figure.caption for figure in list_latex]
	caption_list_pdf = [figure.caption for figure in list_pdf]

	update_list_latex = [figure for figure in list_latex]
	update_list_pdf = [figure for figure in list_pdf]
	
	for index, caption in enumerate(caption_list_latex):
		# transform all latex simbols in unicode
		caption = translate_latex2unicode(caption)
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		update_list_latex[index].caption = caption
		# skip the figure number
		#ur UNICODE RAW
		caption = re.sub(ur'^[\d]+ ', '', caption)
		# ignore unicode chars
		caption = caption.encode('ascii', 'ignore')
		# ignore some \\ fields
		caption = re.sub(r'\\[a-z]+','',caption)
		# delete special chars 
		for char in caption:
			if char in ' _^${}[]':
				caption = caption.replace(char,'')
		# convert again to unicode
		unicode(caption)
		caption_list_latex[index] = caption
		
	# Transformations (special characters and newlines)
	for index, caption in enumerate(caption_list_pdf):
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		caption = strip_control_characters(caption)
		update_list_pdf[index].caption = caption
		# Skip Fig. number. at the beginning
		#ur UNICODE RAW
		caption = re.sub(ur'^Fig\. [\d]+\. ', '', caption)
		caption = re.sub(ur'^Figure [\d]+\: ', '', caption)

		#encode to ascii for eliminating unicode chars
		caption = caption.encode('ascii','ignore')
		caption = caption.replace(' ','')
		#reconvert to unicode
		unicode(caption)
		caption_list_pdf[index] = caption

	return (caption_list_latex, caption_list_pdf, update_list_latex, update_list_pdf)



def doMatching(list_latex, list_pdf):
	"""
	Function that creates tuples of the matched captions.We consider
	a margin coefficient. If the number of differences is less than the
	margin coefficient the captions are simmilar.

	@param list_latex
	@param list_pdf

	@return tuples, update_list_latex, update_list_pdf
	"""
	tuples = []	

	caption_list_latex, caption_list_pdf, update_list_latex, update_list_pdf = get_captions(list_latex, list_pdf)

	
	for index_latex, caption_latex in enumerate(caption_list_latex):
		min_distance = margin_coefficient = 10000
		index = 0
		for index_pdf, caption_pdf in enumerate(caption_list_pdf):
			#the smallest distance
			distance = levenshtein(caption_latex, caption_pdf)
			write_message("(%d, %d) Distance %d" %(index_latex, index_pdf, distance))
			print("(%d, %d) Distance %d" %(index_latex, index_pdf, distance))
			if distance < min_distance:
				min_distance = distance
				if (len(caption_pdf) != 0):
					#margin_coefficient = 15 %
					margin_coefficient = int(( 15 * len(caption_pdf) ) / 100)
				else:
					margin_coeffieicnt = min_distance
				write_message("Margin coefficient: %d"%margin_coefficient)
				print("Margin coefficient: %d"%margin_coefficient)
				#write_message(margin_coefficient)
				index = index_pdf
		if min_distance < margin_coefficient:
			tuples.append((index_latex, index))

	return (tuples, update_list_latex, update_list_pdf)


def index_not_in_tuples(index, tuples, mode):
	"""
	Function that check if an index is in tuples

	@param index
	@param tuples
	@param mode - latex, pdf

	return 0 it is, 1 it's not
	"""
	for t in tuples:
		if(mode == "latex"):
			if(t[0] == index):
				return 0
		if(mode == "pdf"):
			if(t[1] == index):
				return 0
	return 1


def pdf_is_in_multiple_tuples(tuples):
	"""
	Function that checks if a pdf is in multiple tuples
	
	@param tuples: the list of tuples

	@return: a dictionary of pdf with his latex associations
	Example: {pdf:[latex, latex, latex, ...], pdf:[latex, latex, latex, ...], ...}
	"""
	dict = {}
	if len(tuples) == 0:
		return dict
	l, p = max(tuples)
	for i in range(p+1):
		list = []
		count = 0
		index_pdf = 0
		for t in tuples:
			if(t[1] == i):
				list.append(t[0])
				index_pdf = t[1]
				count = count + 1
		if count > 1 :
			dict[index_pdf] = list
	return dict


def similarity(list_latex, list_pdf):
	"""
	The function that takes two lists of figures and detects the matches between them
	
	@param list_latex: the list of latex figures
	@param list_pdf: the list of pdf figures
	
	@return: the matching tuples
	"""
	caption_list_latex = [figure.caption for figure in list_latex]
	caption_list_pdf = [figure.caption for figure in list_pdf]
	
	for index, caption in enumerate(caption_list_latex):
		# transform all latex simbols in unicode
		caption = translate_latex2unicode(caption)
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		list_latex[index].caption = caption
		# when encounter at the beginning the regular expresion: number => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^[\d]+ ', '', caption)
		caption_list_latex[index] = caption
		
	# Transformations (special characters and newlines)
	for index, caption in enumerate(caption_list_pdf):
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		caption = strip_control_characters(caption)
		list_pdf[index].caption = caption
		# when encounter at the beginning the regular expresion: Fig. number. => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^Fig\. [\d]+\. ', '', caption)
		caption = re.sub(ur'^Figure [\d]+\: ', '', caption)
	# used for levenshtein distance
	dictionary = {}
	# used for longest common subsequence
	dictionary2 = {}
	# used for direct comparison
	dictionary3 = {}

	for i in range(len(caption_list_latex)):
		distances = []
		lcss = []
		for j in range(len(caption_list_pdf)):
			distance = levenshtein(caption_list_latex[i], caption_list_pdf[j])
			distances.append(distance)
			X = caption_list_latex[i]
			Y = caption_list_pdf[j]
			m = len(X)
			n = len(Y)
			C = LCS(X, Y)
			lcs = iterative(C, X, Y, m, n)
			lcss.append(lcs)

		max_distance = 0
		index_max = 0
		# the list we use in representing the longest common subsequence
		index_max_elem_list = []
		for k in range(len(lcss)):
			if len(lcss[k]) > max_distance:
				max_distance = len(lcss[k])
				index_max = k
		index_max_elem_list.append(index_max)
		# if there are equal distances
		n = 0
		for k in range(len(lcss)):
			if len(lcss[k]) == max_distance:
				if(n != 0):
					index_max_elem_list.append(k)
				n=1
		
		min_distance = 100000
		# the list we use in representing the levenshtein distance
		index_min_elem_list = []
		# the list for direct comparison
		index_min_direct_comparison = []

		for k in range(len(distances)):
			if distances[k] == 0:
				index_min_direct_comparison.append(k)
			if distances[k] < min_distance:
				min_distance = distances[k]
				index_min = k
		if len(distances) != 0:
			index_min_elem_list.append(index_min)
		# if there are equal distances
		n = 0
		for k in range(len(distances)):
			if distances[k] == min_distance:
				if(n != 0):
					index_min_elem_list.append(k)
				n=1
		
		
		dictionary[i] = index_min_elem_list
		print dictionary
		
		dictionary2[i] = index_max_elem_list
		print dictionary2
		
		dictionary3[i] = index_min_direct_comparison
		print dictionary3
	
	tuples = []
	for i in range(len(dictionary)):
		for j in range(len(dictionary.values()[i])):
			if(dictionary.values()[i] == dictionary2.values()[i]):
			# if dictionary.values()[i] == dictionary3.values()[i]
				a_tuple = i, dictionary.values()[i][j]
				tuples.append(a_tuple)
	return tuples


def similarity_between_caption1_and_caption2(caption1, caption2, list1, list2):
	"""
	Function that takes two lists and two captions and returns if the caption 1 is matching caption 2
	
	@param caption1: caption from pdf source
	@param caption2: caption from latex source
	@param list1: list of pdf figures
	@param list2: list of latex figures
	
	@return: 0 if caption1 matches caption2, -1 else
	"""

	caption_list1 = [element.caption for element in list1]
	caption_list2 = [element.caption for element in list2]
	
	# Transformations (special characters and newlines)
	for index, caption in enumerate(caption_list1):
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		# when encounter at the beginning the regular expresion: Fig. number. => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^Fig\. [\d]+\. ', '', caption)
		caption_list1[index] = caption
	print caption_list1
	for index, caption in enumerate(caption_list2):
		# transform all latex simbols in unicode
		caption = translate_latex2unicode(caption)
		# remove all spaces and new lines and tabs from the beginning, then if a line contains \n, replace with space
		caption = caption.lstrip().replace('\n', ' ')
		# when encounter at the beginning the regular expresion: number => skip
		#ur UNICODE RAW
		caption = re.sub(ur'^[\d]+ ', '', caption)
		caption_list2[index] = caption
	print caption_list2	

	# Long common subsequence
	# Levenshtein distance
	dictionary = {}
	dictionary2 = {}
	dictionary3 = {}

	for i in range(len(caption_list1)):
		distances = []
		lcss = []
		for j in range(len(caption_list2)):
			distance = levenshtein(caption_list1[i], caption_list2[j])
			distances.append(distance)
			X = caption_list1[i]
			Y = caption_list2[j]
			m = len(X)
			n = len(Y)
			C = LCS(X, Y)
			lcs = backTrack(C, X, Y, m, n)
			lcss.append(lcs)

		print distances
		max_distance = 0
		index_max_elem_list = []
		for k in range(len(lcss)):
			if len(lcss[k]) > max_distance:
				max_distance = len(lcss[k])
				index_max = k
		index_max_elem_list.append(index_max)
		# if there are equal distances
		n = 0
		for k in range(len(lcss)):
			if len(lcss[k]) == max_distance:
				if(n != 0):
					index_max_elem_list.append(k)
				n=1	
		
		min_distance = 100000
		index_min_elem_list = []
		index_min_direct_comparison = []

		for k in range(len(distances)):
			if distances[k] == 0:
				index_min_direct_comparison.append(k)
			if distances[k] < min_distance:
				min_distance = distances[k]
				index_min = k
		index_min_elem_list.append(index_min)
		# if there are equal distances
		n = 0
		for k in range(len(distances)):
			if distances[k] == min_distance:
				if(n != 0):
					index_min_elem_list.append(k)
				n=1

		dictionary[i] = index_min_elem_list
		print dictionary

		dictionary2[i] = index_max_elem_list
		print dictionary2
		
		dictionary3[i] = index_min_direct_comparison
		print dictionary3
	
	for caption in caption_list1:
		if caption == caption1:
			index_caption1 = caption_list1.index(caption)
	for caption in caption_list2:
		if caption == caption2:
			index_caption2 = caption_list2.index(caption)
	if index_caption2 in dictionary[index_caption1]:
		if index_caption2 in dictionary2[index_caption1]:
	#		if index_caption2 in dictionary3[index_caption1]
			return 0
	return -1

def getFiles(directory):
	"""
	Function that gets all the files from a directory and sorts them
	
	@param directory: the directory
	
	@return: the files
	"""
	listing = os.listdir(directory)
	listing.sort()
	return listing

def getFigureVectors(file_xml, file_json):
	"""
	Function that receives two files, inserts the information in a class Figure and outputs the list of figures
	from json and xml
	
	@param file_xml: the file xml
	@param file_json: the file json
	
	@return: code, message, list of figures from pdf and from latex
	If code is 0, there are no errors, else code is 1
	The error is found in the message
	"""

	code = 0
	message = ''
	# first check if the file exists
	if os.path.exists(file_xml):
		record = output_record(file_xml)
		# if a file xml doesn't contain the record metadata, return the list empty
		if record != None:
			list_of_figures_from_latex = parse_record(record)
		else:
			code = 1
			now = datetime.datetime.now()
			message = "[" + str(now) + "]: " + "the file " + file_xml + " does not contain the metadata record\n"
			list_of_figures_from_latex = []
	# if not, empty list
	else:
		code = 1
		now = datetime.datetime.now()
		message = "[" + str(now) + "]: " + "the file " + file_xml + " does not exist\n"
		list_of_figures_from_latex = []
	
	
	if os.path.exists(file_json):
		json_to_string = output_string(file_json)
		list_of_figures_from_pdf = parse_json(json_to_string)
	# if not, the list is empty
	else:
		code = 2
		now = datetime.datetime.now()
		message = "[" + str(now) + "]: " + "the file " + file_json + " does not exist\n"
		list_of_figures_from_pdf = []
	
		
	return (code, message, list_of_figures_from_latex, list_of_figures_from_pdf)

def main():
	if len(sys.argv) != 3:
		print 'Error on command line parameters. Usage: bibfigure_merge <file1> <file2>'
	else:
		file1 = sys.argv[1]
		file2 = sys.argv[2]
		merging_latex_pdf(file1, file2)
	
if __name__== "__main__":
	main()
